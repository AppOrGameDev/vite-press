import{_ as o,k as e,l as c,U as d}from"./chunks/framework.a3e818c0.js";const g=JSON.parse('{"title":"数据存储","description":"浏览器中的数据存储方式","frontmatter":{"title":"数据存储","description":"浏览器中的数据存储方式","category":"browser","tags":["browser","storage"]},"headers":[],"relativePath":"frontend/browser/browser-storage.md","filePath":"frontend/browser/browser-storage.md","lastUpdated":1685285908000}'),l={name:"frontend/browser/browser-storage.md"},s=d(`<h1 id="浏览器存储" tabindex="-1">浏览器存储 <a class="header-anchor" href="#浏览器存储" aria-label="Permalink to &quot;浏览器存储&quot;">​</a></h1><p>浏览器的本地存储主要分为 <code>Cookie</code>、<code>WebStorage</code> 和 <code>IndexedDB</code>，其中 <code>WebStorage</code> 又分为 <code>localStorage</code> （本地存储）和 <code>sessionStorage</code>（会话存储）</p><h2 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h2><p><code>cookie</code> 最开始并不是用于本地存储的，而是为了弥补 <code>HTTP</code> 在状态管理上的不足： <code>HTTP</code> 是一个无状态的协议，客户端向服务器发送请求，服务器返回响应，但是下一次发送请求时服务端就无法识别客户端的身份信息，故而产生了 <code>cookie</code>。</p><p><code>cookie</code> 本质上是浏览器里面存储的一个很小的文本文件，内部以键值对的方式存储。向同一个域名下发送请求都会携带相同的 <code>cookie</code> ，服务器拿到 <code>cookie</code> 进行解析，就能拿到客户端的状态。也就是说，<code>cookie</code> 的作用就是用来做状态存储的。</p><p><code>cookie</code> 的具体实现过程：</p><ol><li><p>当用户访问 <code>web</code> 服务器后，<code>web</code> 服务器会获取用户的状态并且返回一些数据（<code>cookie</code>）给浏览器，浏览器会自动储存这些数据（<code>cookie</code>)。</p></li><li><p>当用户再次访问 <code>web</code> 服务器，浏览器会把 <code>cookie</code> 放到请求报文中发送给web服务器，<code>web</code> 服务器就会获取到了用户的状态。</p></li><li><p>基于这次用户的状态方便用户进行其他业务的访问，并且 <code>web</code> 服务器可以设置浏览器保存 <code>cookie</code> 的时间，<code>cookie</code> 是有域名的概念，只有访问同一个域名的时候才会把之前相同域名返回的 <code>cookie</code> 携带给该 <code>web</code> 服务器。</p></li></ol><p>缺陷：</p><ul><li><p>容量缺陷：<code>cookie</code> 的体积上限只有 <code>4KB</code>，只能用来存储少量的信息。</p></li><li><p>性能缺陷：<code>cookie</code> 是紧跟域名的，不管域名下面的某个地址需不需要这个 <code>cookie</code>，它都会携带上完整的 <code>cookie</code> 。这样随着请求数据的增多，很容易造成性能上的浪费。</p></li><li><p>安全缺陷：由于 <code>cookie</code> 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，并在 <code>cookie</code> 的有效期内重新发送给服务器。另外，在 <code>HTTPOnly</code> 为 <code>false</code> 的情况下，<code>cookie</code> 信息能直接通过 <code>JS</code> 脚本读取。</p></li></ul><p>cookie属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>key</td><td>cookie的键（名称）</td></tr><tr><td>value</td><td>cookie的值</td></tr><tr><td>max_age</td><td>cookie被保存的时间数，单位为秒。</td></tr><tr><td>expires</td><td>具体的过期时间，一个datetime对象或UNIX时间戳</td></tr><tr><td>path</td><td>限制cookie只在给定的路径可用，默认为整个域名下路径都可用</td></tr><tr><td>domain</td><td>设置cookie可用的域名，默认是当前域名，子域名需要利用通配符domain=.当前域名</td></tr><tr><td>secure</td><td>如果设为True，只有通过HTTPS才可以用</td></tr><tr><td>httponly</td><td>如果设为True，禁止客户端JavaScript获取cookie</td></tr></tbody></table><h2 id="session" tabindex="-1">session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;session&quot;">​</a></h2><p><code>cookie</code> 和 <code>session</code> 都是用来跟踪浏览器用户的身份的方式，有以下区别：</p><ol><li>保存方式</li></ol><ul><li><p><code>cookie</code> 保存在浏览器端；</p></li><li><p><code>session</code> 保存在服务器端</p></li></ul><ol start="2"><li>使用原理</li></ol><ul><li><p><code>cookie</code> 机制：如果不在浏览器中设置过期时间，<code>cookie</code> 被保存在内存中，生命周期随浏览器的关闭而结束，这种 <code>cookie</code> 简称会话 <code>cookie</code>。如果在浏览器中设置了 <code>cookie</code> 的过期时间，<code>cookie</code> 被保存在硬盘中，关闭浏览器后，<code>cookie</code> 数据仍然存在，直到过期时间结束才消失。</p></li><li><p><code>session</code> 机制：当服务器收到请求需要创建 <code>session</code> 对象时，首先会检查客户端请求中是否包含 <code>session id</code> 。如果有 <code>session id</code>，服务器将根据该 <code>id</code> 返回对应 <code>session</code> 对象。如果客户端请求中没有 <code>session id</code>，服务器会创建新的 <code>session</code> 对象，并把 <code>session id</code> 在本次响应中返回给客户端。</p></li></ul><ol start="3"><li>存储内容</li></ol><ul><li><p><code>cookie</code> 只能保存字符串类型，以文本的方式。</p></li><li><p><code>session</code> 通过类似与 <code>Hashtable</code> 的数据结构来保存，能支持任何类型的对象(<code>session</code> 中可含有多个对象)</p></li></ul><ol start="4"><li>存储的大小</li></ol><ul><li><p><code>cookie</code>：单个 <code>cookie</code> 保存的数据不能超过 <code>4kb</code>。</p></li><li><p><code>session</code>：大小理论上没有限制。</p></li></ul><ol start="5"><li>安全性</li></ol><ul><li><p><code>cookie</code>：针对 <code>cookie</code> 所存在的攻击：<code>cookie</code> 欺骗，<code>cookie</code> 截获；</p></li><li><p><code>session</code> 的安全性大于 <code>cookie</code>。</p></li></ul><ol start="6"><li>应用场景</li></ol><ul><li><p>cookie：</p><ul><li><p>判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除 <code>cookie</code>，则每次登录必须重新填写登录的相关信息。</p></li><li><p>保存上次登录的时间等信息。</p></li><li><p>保存上次查看的页面</p></li><li><p>浏览计数</p></li></ul></li><li><p>session：<code>Session</code> 用于保存每个用户的专用信息，变量的值保存在服务器端，通过 <code>SessionID</code> 来区分不同的客户。</p><ul><li><p>网上商城中的购物车</p></li><li><p>保存用户登录信息</p></li><li><p>将某些数据放入 <code>session</code> 中，供同一用户的不同页面使用</p></li><li><p>防止用户非法登录</p></li></ul></li></ul><ol start="7"><li>缺点</li></ol><ul><li><p>cookie：</p><ul><li><p>大小受限，不能超过 <code>4kb</code>；</p></li><li><p>用户可以操作（禁用）<code>cookie</code>，使功能受限；</p></li><li><p>安全性较低；</p></li><li><p>有些状态不能保存在客户端；</p></li><li><p>每次访问都要传送 <code>cookie</code> 给服务器，浪费带宽；</p></li><li><p><code>cookie</code> 数据有路径（<code>path</code>）的概念，可以限制 <code>cookie</code> 只属于某个路径下。</p></li></ul></li><li><p>session：</p><ul><li><p><code>Session</code> 保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p></li><li><p>依赖于 <code>cookie</code>（<code>session id</code> 保存在 <code>cookie</code>），如果禁用 <code>cookie</code>，则要使用 <code>URL</code> 重写，不安全</p></li><li><p>创建 <code>session</code> 变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用 <code>session</code> 变量将会导致代码不可读而且不好维护。</p></li></ul></li></ul><h2 id="web-storage-api" tabindex="-1">Web storage API <a class="header-anchor" href="#web-storage-api" aria-label="Permalink to &quot;Web storage API&quot;">​</a></h2><ul><li><p><code>Web Storage</code> 存储机制是对 <code>HTML4</code> 中 <code>cookie</code> 存储机制的一个改善。由于 <code>cookie</code> 存储机制有很多缺点，<code>HTML5</code> 不再使用它，转而使用改良后的 <code>Web Storage</code> 存储机制。</p></li><li><p><code>Web Storage</code> 提供两种类型的 <code>API</code>：<code>localStorage</code> 在本地永久性存储数据，除非显式将其删除或清空；<code>sessionStorage</code> 存储的数据只在会话期间有效，关闭浏览器则自动删除。</p></li></ul><h3 id="localstorage" tabindex="-1">localStorage <a class="header-anchor" href="#localstorage" aria-label="Permalink to &quot;localStorage&quot;">​</a></h3><p><code>localStorage</code> 的存储都是字符串，如果是存储对象，那么在存储时就需要调用 <code>JSON.stringify</code> 方法，并且在取值时用 <code>JSON.parse</code> 来解析成对象。</p><p>与cookie的异同： 同： 针对一个域名，即在同一域名下，会存储同一段 <code>localStorage</code>。</p><p>异：</p><ul><li><p>容量：<code>localStorage</code> 的容量上线为 <code>5MB</code>。</p></li><li><p>只存储在客户端，默认不参与与服务器端的通讯，这样就很好的避免了 <code>cookie</code> 带来的性能和安全问题。</p></li><li><p>接口封装：通过 <code>localStorage</code> 暴露在全局，并通过它的 <code>setItem</code> 和 <code>getItem</code> 等方法进行操作。</p></li></ul><p>应用场景： 因为 <code>localStorage</code> 的较大容量和持久特性，可以利用 <code>localStorage</code> 存储一些内容稳定的资源；例如官网的 <code>logo</code>，存储 <code>Base64</code> 格式的图片资源。</p><h3 id="sessionstorage" tabindex="-1">sessionStorage <a class="header-anchor" href="#sessionstorage" aria-label="Permalink to &quot;sessionStorage&quot;">​</a></h3><p>将数据保存在 <code>session</code> 对象中。所谓 <code>session</code> ，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。<code>session</code> 对象可以用来保存在这段时间内所要求保存的任何数据。</p><p>与localStorage的异同：</p><p>同：</p><ul><li><p>容量：<code>sessionStorage</code> 的容量上线也为 <code>5MB</code>。</p></li><li><p>只存储在客户端，默认不参与与服务器端的通讯。</p></li><li><p>接口封装：除了名字变化，<code>sessionStorage</code> 的存储方式和操作方式均和 <code>localStorage</code> 一样。</p></li><li><p><code>localStorage</code> 和 <code>sessionStorage</code> 只能存储字符串类型。</p></li></ul><p>异：</p><ul><li><p><code>sessionStorage</code> 将数据保存在 <code>Session</code> 对象中。而 <code>localStorage</code> 将数据保存在客户端本地的硬件设备，即使浏览器被关闭了该数据依然存在，下次打开浏览器访问网站时可以继续使用。</p></li><li><p><code>localStorage</code> 的生命周期是永久的，<code>sessionStorage</code> 的生命周期是在仅在当前会话下有效。</p></li></ul><p>应用场景：</p><ul><li><p>可以使用 <code>sessionStorage</code> 对表单进行维护，将表单信息存储在里面，即使刷新表单也能保证不会让之前的表单信息丢失。</p></li><li><p>可以使用 <code>sessionStorage</code> 来存储本次浏览记录，即那种关闭页面就不需要的浏览记录。</p></li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Storage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setItem</span><span style="color:#A6ACCD;">(name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> key) ：设置值</span></span>
<span class="line"><span style="color:#A6ACCD;">Storage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getItem</span><span style="color:#A6ACCD;">(name)：获取</span></span>
<span class="line"><span style="color:#A6ACCD;">Storage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">removeItem</span><span style="color:#A6ACCD;">(name)：删除</span></span>
<span class="line"><span style="color:#A6ACCD;">Storage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">clear</span><span style="color:#A6ACCD;">()：删除所有值</span></span>
<span class="line"><span style="color:#A6ACCD;">Storage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">key</span><span style="color:#A6ACCD;">()：获取键值</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="indexeddb" tabindex="-1">indexedDB <a class="header-anchor" href="#indexeddb" aria-label="Permalink to &quot;indexedDB&quot;">​</a></h2><p>当数据量不大时，我们可以通过 <code>sessionStorage</code> 或者 <code>localStorage</code> 来进行存储，但是当数据量较大，或符合一定的规范时，我们可以使用 <code>indexedDB</code> 数据库来进行数据的存储，<code>indexedDB</code> 数据库存储理论上没有大小的限制。</p><p><code>IndexedDB</code> 鼓励使用的基本模式如下所示：</p><ul><li><p>打开数据库。</p></li><li><p>在数据库中创建一个对象仓库（<code>object store</code>）。</p></li><li><p>启动一个事务，并发送一个请求来执行一些数据库操作，像增加或提取数据等。</p></li><li><p>通过监听正确类型的 <code>DOM</code> 事件以等待操作完成。</p></li><li><p>在操作结果上进行一些操作（可以在 <code>request</code> 对象中找到）</p></li></ul><p>缺点：<code>indexedDB</code> 属于非关系型数据库，操作繁琐，对新手不友好</p>`,50),i=[s];function a(t,p,r,n,k,u){return e(),c("div",null,i)}const h=o(l,[["render",a]]);export{g as __pageData,h as default};
