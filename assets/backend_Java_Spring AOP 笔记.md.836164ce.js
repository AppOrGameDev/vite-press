import{_ as s,o as n,c as a,U as e}from"./chunks/framework.c0c21d38.js";const F=JSON.parse('{"title":"Spring AOP 切面/(通知)/注解","description":"","frontmatter":{},"headers":[],"relativePath":"backend/Java/Spring AOP 笔记.md","filePath":"backend/Java/Spring AOP 笔记.md","lastUpdated":1715588899000}'),l={name:"backend/Java/Spring AOP 笔记.md"},o=e(`<h1 id="spring-aop-切面-通知-注解" tabindex="-1">Spring AOP 切面/(通知)/注解 <a class="header-anchor" href="#spring-aop-切面-通知-注解" aria-label="Permalink to &quot;Spring AOP 切面/(通知)/注解&quot;">​</a></h1><h2 id="aop通知" tabindex="-1">AOP通知 <a class="header-anchor" href="#aop通知" aria-label="Permalink to &quot;AOP通知&quot;">​</a></h2><h3 id="通知注解的执行时机和顺序" tabindex="-1">通知注解的执行时机和顺序 <a class="header-anchor" href="#通知注解的执行时机和顺序" aria-label="Permalink to &quot;通知注解的执行时机和顺序&quot;">​</a></h3><ul><li><code>环绕通知</code> @Around注解方法的前半部分业务逻辑</li><li><code>前置通知</code> @Before注解方法的业务逻辑</li><li><code>被代理函数</code> 目标方法的业务逻辑</li><li><code>后置返回通知</code> @AfterReturning（<code>若目标方法无异常，执行@AfterReturning注解方法的业务逻辑</code>）</li><li><code>后置异常通知</code> @AfterThrowing（<code>若目标方法有异常，执行@AfterThrowing注解方法的业务逻辑</code>）</li><li><code>后置通知</code> @After（不管目标方法有无异常，都会执行@After注解方法的业务逻辑）</li><li><code>环绕通知</code> @Around注解方法的后半部分业务逻辑（<code>@Around注解方法内的业务逻辑若对ProceedingJoinPoint.proceed()方法没做捕获异常处理，直接向上抛出异常，则不会执行Around注解方法的后半部分业务逻辑；若做了异常捕获处理，则会执行</code>）。</li></ul><div class="language-java line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">doAround</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;font-style:italic;">//对应@Around注解的方法切面逻辑  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">doBefore</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;font-style:italic;">//对应@Before注解的方法切面逻辑  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">        method</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">doAfterReturning</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;font-style:italic;">//对应@AfterReturning注解的方法切面逻辑  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Exception</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">exp</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">doAfterThrowing</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;font-style:italic;">//对应@AfterThrowing注解的方法切面逻辑  </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> exp</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">doAfter</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;font-style:italic;">//对应@After注解的方法切面逻辑  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">doAround</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;font-style:italic;">//对应@Around注解的方法切面逻辑     </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><code>后置返回通知</code> @AfterReturning和<code>后置异常通知</code> @AfterThrowing<strong style="color:red;">只会有一个被执行;就看代理函数是否执行抛出异常</strong></p><h4 id="多个切面的加到同一个注解上时-根据切面中-order-7-中的数字决定执行顺序" tabindex="-1">多个切面的加到同一个注解上时,根据切面中<code>@Order(7)</code>中的数字决定执行顺序; <a class="header-anchor" href="#多个切面的加到同一个注解上时-根据切面中-order-7-中的数字决定执行顺序" aria-label="Permalink to &quot;多个切面的加到同一个注解上时,根据切面中\`@Order(7)\`中的数字决定执行顺序;&quot;">​</a></h4><ul><li><code>order数字越小，越早执行</code></li></ul><h3 id="综上所述画的流程示意图如下" tabindex="-1">综上所述画的流程示意图如下 <a class="header-anchor" href="#综上所述画的流程示意图如下" aria-label="Permalink to &quot;综上所述画的流程示意图如下&quot;">​</a></h3><p>![](img/Spring AOP 执行时机和顺序示意图.jpg)</p>`,10),p=[o];function r(t,c,i,d,A,y){return n(),a("div",null,p)}const u=s(l,[["render",r]]);export{F as __pageData,u as default};
