# HTTP 和 HTTPS

## HTTP

HTTP是一种用于传输超文本的协议，是互联网上应用最为广泛的协议之一。

1. HTTP的基本概念

- HTTP是一个无状态协议：即每个请求之间是没有关联的，每个请求都是独立的。
- HTTP是基于请求和响应的：客户端发送请求给服务器，服务器返回响应给客户端。
- HTTP是文本协议：HTTP使用文本格式进行通信，请求和响应都是由头部和主体两部分组成的文本格式。

2. HTTP的工作原理

- 客户端发起请求：客户端使用HTTP协议向服务器发送请求，请求包含请求方法、请求URL、请求头和请求主体等信息。
- 服务器响应请求：服务器接收到客户端的请求后，进行处理并返回响应，响应包含状态码、响应头和响应主体等信息。
- 连接关闭：完成请求和响应之后，客户端和服务器之间的连接会被关闭。

HTTP的常见请求方法：

| 方法      | 作用              |
|---------|-----------------|
| GET     | 获取资源            |
| POST    | 提交数据            |
| PUT     | 更新资源            |
| DELETE  | 删除资源            |
| HEAD    | 获取响应头信息         |
| OPTIONS | 获取服务器支持的请求方法等信息 |

HTTP的状态码用于表示服务器处理请求的结果，常见的状态码有200 OK、404 Not Found、500 Internal Server Error等。其中，200表示成功，404表示资源未找到，500表示服务器内部错误等。

总的来说，HTTP是一种简单、可靠、可扩展的协议，它在互联网中扮演着重要的角色，被广泛应用于Web开发、移动应用、API接口等领域。


### GET与POST的区别

GET和POST是HTTP协议中常用的两种请求方法，它们之间的主要区别如下：

1. 参数传递方式不同

- GET请求：参数是通过URL传递的，即将参数拼接在URL后面。
- POST请求：参数是通过请求体传递的，即将参数放在请求体中，请求头中会包含Content-Type字段来说明请求体中的数据格式。

2. 参数传递大小限制不同

- GET请求：由于参数是通过URL传递的，因此传递的参数大小有限制，通常不超过2KB。
- POST请求：由于参数是通过请求体传递的，因此传递的参数大小没有限制。

3. 安全性不同

- GET请求：参数是暴露在URL中的，因此在请求过程中容易被拦截、篡改或缓存，不适合传递敏感信息。
- POST请求：参数是放在请求体中的，相对于GET请求更安全，适合传递敏感信息。

4. 缓存机制不同

- GET请求：浏览器会缓存GET请求的结果，下次请求相同的URL时，直接从缓存中获取，不会重新请求服务器。
- POST请求：浏览器不会缓存POST请求的结果，每次请求都会向服务器发送请求。

5. 应用场景不同

- GET请求：通常用于获取数据，如搜索、分页等。
- POST请求：通常用于提交数据，如登录、注册等。

总之，GET和POST请求各有优缺点，需要根据实际业务需求选择合适的请求方法。

### HTTP报文的组成成分

HTTP报文是HTTP协议中的核心概念之一，包括两部分：请求报文和响应报文。

请求报文包括请求行、请求头、请求体三部分，格式如下：

```
<method> <request-URL> <version>
<headers>
<body>
```

其中：

- 请求行：包括请求方法、请求URL和协议版本，用空格分隔；
- 请求头：包括多个键值对，每个键值对用冒号分隔，多个键值对之间用回车符和换行符分隔；
- 请求体：用于携带请求参数和数据，请求体可以为空。

响应报文也包括三部分：状态行、响应头和响应体，格式如下：

```
<version> <status> <reason-phrase>
<headers>
<body>
```

其中：

- 状态行：包括协议版本、状态码和状态消息，用空格分隔；
- 响应头：包括多个键值对，每个键值对用冒号分隔，多个键值对之间用回车符和换行符分隔；
- 响应体：用于携带响应结果和数据，响应体可以为空。

总体来说，HTTP报文是一个文本格式的信息，它包含了请求或响应所需要的全部信息，使得客户端和服务器端能够有效地进行通信和数据传输。

### Request Header

Request Header（请求头）是HTTP请求报文中的一部分，包含了客户端（浏览器或应用程序）向服务器发送请求时的附加信息，以键值对的形式组织。常见的请求头有：

- User-Agent：客户端的类型及版本号
- Referer：请求来源的URL
- Accept：客户端支持的MIME类型
- Accept-Language：客户端支持的语言类型
- Accept-Encoding：客户端支持的压缩类型
- Host：请求的服务器域名
- Connection：客户端与服务器之间连接的类型
- Cookie：客户端存储的Cookie信息
- Cache-Control：请求缓存的控制参数

请求头的作用是提供给服务器更多的信息，以便服务器更好地处理请求。

### Response Header

Response Header（响应头）是HTTP响应报文中的一部分，包含了服务器对客户端请求的响应信息，以键值对的形式组织。常见的响应头有：

- Content-Type：响应内容的MIME类型
- Content-Length：响应内容的长度
- Cache-Control：响应缓存的控制参数
- Set-Cookie：服务器要求客户端存储的Cookie信息
- Location：重定向的URL地址
- ETag：资源的标识符，用于缓存控制
- Last-Modified：资源的最后修改时间，用于缓存控制
- Expires：资源的过期时间，用于缓存控制

响应头的作用是告知客户端服务器对请求的响应情况，以便客户端进行下一步处理。

## HTTPS

1. https 的基本概念

HTTPS是HTTP协议的一种安全版本，通常使用SSL/TLS协议进行加密。它在数据传输的过程中使用了公钥加密和私钥解密的方式来保护数据的机密性和完整性。HTTPS协议在数据传输过程中，采用了多种加密技术，包括对称密钥加密、非对称密钥加密和消息摘要算法等。这些技术保证了数据在传输过程中不会被黑客窃取或篡改。

2. HTTPS 的作用

使用HTTPS协议可以防止中间人攻击、身份伪装、数据篡改、数据窃听等问题。通过数字证书，可以验证网站的真实性，确保通信双方的身份，保障用户的隐私和安全。

### http 和 https 的区别

HTTP和HTTPS都是应用层协议，但HTTPS在HTTP的基础上增加了安全层，使得数据在传输过程中更加安全可靠。下面是HTTP和HTTPS的区别：

1. HTTP使用明文传输数据，而HTTPS通过SSL/TLS加密数据传输；
2. HTTP的默认端口是80，HTTPS的默认端口是443；
3. HTTP在通信过程中没有身份验证，而HTTPS通过SSL/TLS建立身份验证机制，可以防止身份被冒充；
4. HTTP数据传输速度更快，因为HTTPS增加了加密、解密和身份验证等额外的步骤，需要消耗更多的计算资源和时间；
5. HTTP使用的证书是申请成本较低的DV（Domain Validation）证书，而HTTPS使用的证书是成本较高的EV（Extended Validation）证书，可以提供更高的安全性和可信度。

总之，HTTPS比HTTP更加安全可靠，但在性能方面会有一定的损失。因此，在对安全性要求较高的场合，应该使用HTTPS。

### https 协议的优缺点

https协议相比http协议，具有以下优点和缺点：

**优点：**

1. 安全性高：https协议利用SSL/TLS加密传输数据，能够有效地保障数据的安全性，可以防止数据被窃取、篡改、劫持等攻击。

2. 防止中间人攻击：https采用了证书机制，能够有效地防止中间人攻击。

3. 提高网站的信誉度：https协议能够保证网站的真实性和完整性，让用户更加信任网站，从而提高了网站的信誉度。

4. 支持更多的浏览器和搜索引擎：现在的浏览器和搜索引擎都支持https协议，使用https协议能够让网站更好的展示在搜索结果中，提高曝光率。

**缺点：**

1. 加密、解密过程会消耗更多的计算资源和时间，会降低服务器的性能，增加服务器的负担。

2. 证书需要向CA机构购买，成本较高，不是所有的网站都能够承受。

3. https协议对缓存的支持不够好，会导致网站的访问速度较慢，需要额外的服务器资源来支持https的加密和解密过程。

4. https协议无法缓存静态文件，对于一些大文件的下载，https的效率并不是很高。

综上所述，https协议虽然有一些缺点，但是其安全性和信誉度优势明显，对于一些需要保障数据安全的网站和交易场景，采用https协议是必要的。

### TCP/IP网络模型

TCP/IP网络模型是互联网最基本的通信模型，它是由两个协议簇（Protocol Suite）组成：TCP（传输控制协议）和IP（网际协议）。

TCP/IP网络模型共分为四层，分别为：

1.应用层（Application Layer）：处理特定应用程序的协议，例如HTTP、FTP、SMTP等。

2.传输层（Transport Layer）：提供端到端的接口，负责向两台主机中的应用程序提供通信服务，常用协议有TCP、UDP等。

3.网络层（Internet Layer）：处理网络上的流量路由和寻址，主要包括IP协议。

4.数据链路层（Link Layer）：负责处理网络物理设备和网络之间的数据传输，常用协议有Ethernet、PPP等。

TCP/IP网络模型与OSI网络模型相似，但是它们之间存在一些差异。TCP/IP网络模型是一个更加实用的模型，主要应用于互联网和局域网等通信网络。

## TCP 三次握手

1. 第一次握手：客户端向服务器发送SYN包（SYN=j）并进入SYN_SENT状态，等待服务器确认。
2. 第二次握手：服务器收到客户端的SYN包后，确认客户端的SYN（ACK=j+1），并向客户端发送一个自己的SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。
3. 第三次握手：客户端收到服务器的SYN+ACK包后，向服务器发送确认包ACK（ACK=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，TCP连接建立成功。

:::warning
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
:::


## TCP 四次挥手

1. 客户端发送连接释放报文段（FIN=1，seq=x），并进入FIN_WAIT_1状态，等待服务端确认。
2. 服务端收到连接释放报文段后，发送确认报文段（ACK=1，ack=x+1），进入CLOSE_WAIT状态，等待客户端发送连接释放报文段。
3. 如果服务端有要发送的数据，会先将数据发送完毕，然后发送连接释放报文段（FIN=1，seq=y），进入LAST_ACK状态，等待客户端确认。
4. 客户端收到连接释放报文段后，发送确认报文段（ACK=1，ack=y+1），进入TIME_WAIT状态，等待2MSL后进入CLOSED状态。2MSL是为了确保服务端收到了确认报文段，如果没有收到则会重传连接释放报文段。
5. 服务端收到客户端发送的确认报文段后，进入CLOSED状态，释放连接。
6. 客户端等待2MSL后，确认服务端已经收到了确认报文段，进入CLOSED状态，释放连接。

总结来说，TCP四次挥手过程的目的是为了确保客户端和服务端都知道连接已经关闭，并且在关闭连接之前，双方都有机会传递完所有的数据。在这个过程中，双方都会进入一些状态来等待对方的确认和数据传输。

## TCP 和 UDP 的区别

TCP和UDP是传输层协议，用于在网络上传输数据，但它们之间有几个重要的区别。

1. 可靠性：TCP是可靠的，它确保数据包的正确性和完整性。它使用三次握手建立连接，确认数据包的接收，并保证数据包的顺序。而UDP则是不可靠的，因为它不保证数据包的正确性、完整性和顺序。

2. 连接：TCP是面向连接的协议，建立连接、数据传输和释放连接都需要经过一定的过程。UDP则是无连接的，发送端只是直接把数据包发送给接收端，不需要连接的建立和释放过程。

3. 效率：UDP比TCP快，因为它不需要建立连接和保证数据包的可靠传输。但是，由于UDP不保证数据包的可靠性和完整性，所以需要应用程序来负责处理这些问题。

4. 应用场景：TCP适用于需要可靠数据传输的应用程序，如文件传输、电子邮件、Web应用程序等。UDP适用于需要快速数据传输的应用程序，如视频、音频、游戏等。

总之，TCP提供了可靠性和顺序控制，而UDP提供了快速传输和更少的开销。选择哪种协议取决于应用程序的需求和特点。

## HTTP 请求跨域问题

跨域问题是指浏览器限制了当前网页从不同的域名、端口、协议访问另一个网站的资源的限制。浏览器是基于同源策略来限制跨域访问的。

同源策略指的是：协议、域名、端口号必须完全相同
解决跨域值的是：通过各种方式，避开浏览器的安全限制

常见的跨域解决方案有以下几种：

1. JSONP：通过动态创建`<script>`标签，通过`src`属性加载一个`API`，并在`url`参数中携带回调函数名，服务端返回一个执行该回调函数的`JavaScript`脚本。`JSONP`仅支持`GET`
   请求，且只能用于跨域获取数据，无法实现向服务器提交数据。
2. CORS：服务器设置响应头中的`Access-Control-Allow-Origin`字段，允许指定的域名跨域访问该资源。使用`CORS`需要服务器端支持，且需要前端进行额外的配置，可以支持`GET/POST`等请求类型。
3. 代理服务器：前端请求自己的服务器，自己的服务器再去请求目标服务器，最后将目标服务器的响应返回给前端。由于是同源请求，不存在跨域问题，但需要在自己的服务器上进行配置。
4. `WebSocket`：`WebSocket`协议是一种在单个`TCP`连接上进行全双工通信的协议，它不受同源策略的限制。通过在客户端和服务器之间建立`WebSocket`连接，可以在跨域情况下进行实时通信。
5. `postMessage`：可以在跨域的窗口之间发送消息，通过对消息的监听来实现跨域通信。

## HTTP状态码

### 状态码类型

- 1xx：信息提示，表示请求已被接受，需要继续处理。
- 2xx：成功，表示请求已被成功处理和接受。
- 3xx：重定向，表示需要进行进一步操作才能完成请求。
- 4xx：客户端错误，表示请求包含错误或无法被处理。
- 5xx：服务器错误，表示服务器在尝试处理请求时发生了错误。

### 常见状态码

- 200 OK：客户端请求成功
- 301 Moved Permanently：所请求的页面已经永久重定向至新的URL
- 302 Found：所请求的页面已经临时重定向至新的URL
- 304 Not Modified 未修改。
- 403 Forbidden：对请求页面的访问被禁止
- 404 Not Found：请求资源不存在
- 500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用
- 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常

### 更多状态码

- 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码
  - 100：继续，服务器已经接收到请求头，并且客户端应该继续发送请求体（通常用于POST请求）。
  - 101：切换协议，请求者已要求服务器切换协议，服务器已确认并准备切换

- 2xx（成功）表示成功处理了请求的状态码
  - `200`：成功，服务器已经成功处理了请求
  - 201：已创建，请求成功并且服务器创建了新的资源
  - 202：已接受，服务器已接受请求，但尚未处理
  - 203：非授权信息，服务器已经成功处理了请求，但返回的信息可能来自另一来源
  - 204：无内容，服务器成功处理了请求，但没有返回任何内容
  - 205：重置内容，服务器成功处理了请求，但没有返回任何内容

- 3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向
  - 300：多种选择，针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择
  - `301`：永久移动，请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置
  - `302`：临时移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
  - 303：查看其它位置，请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码
  - `304`：未修改，自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容
  - 305：使用代理，请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
  - `307`：临时性重定向，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求

- 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理
  - `400`：错误请求 服务器不理解请求的语法
  - `401`：未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
  - `403`：禁止 服务器拒绝请求
  - `404`：未找到 服务器找不到请求的网页
  - 405：方法禁用 禁用请求中指定的方法
  - 406：不接受 无法使用请求的内容特性响应请求的网页
  - `407`：需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理
  - `408`：请求超时 服务器等候请求时发生超时
  - 410：已删除 如果请求的资源已永久删除，服务器就会返回此响应
  - `413`：请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力
  - `414`：请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理


- 5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错
  - `500`：服务器内部错误 服务器遇到错误，无法完成请求
  - 501：尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
  - `502`：错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应
  - `503`：服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
  - `504`：网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求
  - 505：HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本

## HTTP 304状态码的过程

对于HTTP 304状态码的过程，可以总结如下：

1. 浏览器请求资源时，先检查资源的 `Expires` 和 `Cache-Control` 值，如果缓存仍然有效，则直接使用缓存，返回状态码200，并在响应头中添加 `from cache` 字样，不会请求数据。

2. 如果缓存失效，浏览器发送带有 `If-None-Match` 和 `If-Modified-Since` 头的条件请求到服务器，请求头中的 `If-None-Match` 值是上一次请求返回的 `ETag` 值，`If-Modified-Since`
   是上一次请求返回的 `Last-Modified` 值。

3. 服务器收到条件请求后，检查资源的 `ETag` 和 `Last-Modified` 值是否匹配，如果匹配，则表示资源没有更新，返回状态码304，告诉浏览器可以直接使用缓存。

4. 如果资源已更新，则服务器返回新的资源，状态码为200，并在响应头中添加新的 `ETag` 和 `Last-Modified` 值，浏览器会更新缓存，并在下一次请求中使用新的缓存。

总之，HTTP 304状态码的过程是一种优化缓存机制的方式，减少网络带宽和服务器负载。通过比较资源的 `ETag` 和 `Last-Modified` 值，避免了不必要的数据传输，提高了资源请求的效率。

## 浏览器的缓存机制

浏览器缓存机制可以分为强制缓存和协商缓存两种方式。

强制缓存：

当浏览器第一次请求资源时，服务器返回的响应头中会包含 `Cache-Control` 和 `Expires` 字段，用于控制资源的缓存。浏览器在接收到资源后，会将其保存到本地，并在下一次请求该资源时，先判断本地缓存是否过期，如果未过期，则直接从本地缓存读取资源，不再向服务器发起请求。

协商缓存：

当浏览器判断本地缓存已经过期时，会向服务器发起请求，服务器返回的响应头中会包含 `Last-Modified` 和 `ETag`
字段，用于标识资源的最后修改时间和唯一标识。浏览器在接收到资源后，会将其保存到本地，并在下一次请求该资源时，先向服务器发起请求，请求头中包含上一次响应头中返回的 `Last-Modified` 和 `ETag`
值，服务器会根据这些值判断该资源是否有更新，如果没有更新，则返回 304 状态码，并告诉浏览器可以从本地缓存中获取该资源；如果有更新，则返回新的资源内容和响应头，并将其保存到本地缓存。

## 粘包问题分析与对策

TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

**粘包出现原因**

粘包问题是指在网络通信过程中，由于数据包较小或传输速度过快，多个数据包被缓存在发送方，最终一次性发送到接收方，导致接收方无法正确区分各个数据包之间的边界，从而导致数据包的内容出现混乱或解析错误的问题。

粘包问题产生的原因主要有两个：

1. 发送方缓存数据包过多或传输速度过快，导致多个数据包一次性发送。
2. 接收方读取数据包的方式不当，比如采用固定长度的方式读取数据，而不考虑数据包之间的边界问题。

针对粘包问题，可以采取以下几种对策：

1. 消息定长：发送方发送的消息长度固定，接收方按照固定长度读取数据包。
2. 在数据包中增加特殊字符分隔符：发送方在数据包尾部添加特定分隔符，接收方根据分隔符切分数据包。
3. 将消息分为消息头和消息体：消息头中包含数据包长度等信息，接收方先读取消息头中的信息，再按照消息头中的长度读取消息体。
4. 使用更高级别的协议：比如TCP协议提供了流控制、拥塞控制等机制，可以保证传输的可靠性，同时也能够避免粘包问题的产生。

## 客户端与服务端长连接的几种方式

1. **ajax 轮询**
   **实现原理**：ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。

   **优点**：可实现基础（指间隔时间较短）的数据更新。

   **缺点**
   ：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。【`数据更新不及时，效率低下`】

2. **long poll 长轮询**

   **实现原理**：
   long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0
   中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在
   HTTP1.1 中默认使用了 Connection:keep-alive 长连接。

   **优点**：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。

   **缺点**：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP
   连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。【`无法处理高并发，消耗服务器资源严重，服务端不能主动推送`】

3. **iframe 长连接**

   **实现原理：**\
   在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。

   **优点**：消息及时传输。

   **缺点**：`消耗服务器资源`。

4. **WebSocket**

   **实现原理**：
   Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。

   Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。

   Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。

   **优点**：
   双向通信。客户端和服务端双方都可以主动发起通讯。
   没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。
   数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。
   传输效率高。因为只需要一次连接，所以数据传输效率高。

   **缺点**：
   长连接需要后端处理业务的代码更稳定，推送消息相对复杂；\
   长连接受网络限制比较大，需要处理好重连。\
   兼容性，WebSocket 只支持 IE10 及其以上版本。\
   服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；\
   成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决。【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】

## 利用Socket建立网络连接的步骤

建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。

套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。

为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。

而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。


## 非对称加密RSA

1. 对称加密算法又称现代加密算法。
2. 非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。
3. 非对称加密算法需要两个密钥：公开密钥(`publickey`) 和私有密(`privatekey`)
4. 公开密钥和私有密钥是一对

如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。

特点： 算法强度复杂，安全性依赖于算法与密钥。 加密解密速度慢。

与对称加密算法的对比： 对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。 非对称加密有两种密钥，其中一个是公开的。

RSA应用场景： 由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取 数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。

## HTTP1、HTTP2、HTTP3

HTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP/2并非完美的，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。

- HTTP/1.1有两个主要的缺点：安全不足和性能不高。
- HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；
- QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。

### **HTTP1.1 的缺陷**

1. 高延迟 — 队头阻塞(Head-Of-Line Blocking)

   `队头阻塞`是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。

   针对队头阻塞的解决办法:

- `将同一页面的资源分散到不同域名下，提升连接上限`。 -   `合并小文件减少资源数`，使用精灵图。
- `内联(Inlining)资源`是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。
- `减少请求数量`，合并文件。

2. 无状态特性 — 阻碍交互

   `无状态是指协议对于连接状态没有记忆能力`。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。

   `Header里携带的内容过大，在一定程度上增加了传输的成本`。且请求响应报文里有大量字段值都是重复的。

3. 明文传输 — 不安全性

   HTTP/1.1在传输数据时，所有`传输的内容都是明文`，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。

4. 不支持服务端推送

> 记忆口诀：队头阻塞高延迟，无状态阻交互，明文传输不安全，服务推送不支持。

**HTTP 1.1 排队问题**

HTTP 1.1多个文件共用一个TCP，这样可以减少tcp握手，这样3个文件就不用握手9次了，不过这样请求文件需要排队，请求和返回都需要排队， 如果第一个文件响应慢，会阻塞后面的文件，这样就产生了对头的等待问题。

有的网站可能会有很多文件，浏览器处于对机器性能的考虑，它不可能让你无限制的发请求建连接，因为建立连接需要占用资源，浏览器不想把用户的网络资源都占用了，所以浏览器最多会建立6个tcp连接；如果有上百个文件可能都需要排队，http2.0正在解决这个问题。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ecdc60670194df7957ee59e1f56701f~tplv-k3u1fbpfcp-watermark.image?)


### SPDY 协议与 HTTP/2 简介

#### 1、HTTP/2 简介

HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写。**HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）** 。

#### 2、HTTP/2 新特性

#### 1、二进制传输

`HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩`。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文
，二进制协议解析起来更高效。`HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码`。

#### 2、Header 压缩

HTTP/2并没有使用传统的压缩算法，而是开发了专门的"HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

#### 3、多路复用

在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f756ad3403bc4fe18e970c56677c796e~tplv-k3u1fbpfcp-watermark.image?)

#### 4、Server Push

HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。减少等待的延迟，这被称为"`服务器推送`"（ Server Push，也叫 Cache
push）

#### 5、提高安全性

出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。

但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，**所以“事实上”的HTTP/2是加密的**。也就是说，互联网上通常所能见到的HTTP/2都是使用"
https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2"表示加密的HTTP/2，“h2c”表示明文的HTTP/2。

#### 6、防止对头阻塞

http1.1如果第一个文件阻塞，第二个文件也就阻塞了。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67bd1f793a3425d9e8a415cae9b7863~tplv-k3u1fbpfcp-watermark.image?)

http2.0的解决，把3个请求打包成一个小块发送过去，即使第一个阻塞了，后面2个也可以回来；相当于3个文件同时请求，就看谁先回来谁后回来，阻塞的可能就后回来，对带宽的利用是最高的；但没有解决TCP的对头阻塞，如果TCP发过去的一个分包发丢了，他会重新发一次；http2.0的解决了大文件的阻塞。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d8ae8e0de44f3aa693f0626a346d4c~tplv-k3u1fbpfcp-watermark.image?)

一个分包请求3个文件，即使第一个阻塞了，第二个也能返回

### HTTP/2 的缺点

虽然 HTTP/2 解决了很多之前旧版本的问题，但它还是存在一个巨大的问题，**主要是底层支撑的 TCP 协议造成的**。HTTP/2的缺点主要有以下几点：

1. TCP 以及 TCP+TLS 建立连接时延时
2. TCP 的队头阻塞并没有彻底解决
3. 多路复用导致服务器压力上升也容易 Timeout

### HTTP/3 新特性

#### 1、HTTP/3简介

Google 在推SPDY的时候就搞了个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而“HTTP over QUIC”就是HTTP/3，真正“完美”地解决了“队头阻塞”问题。

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。

#### 2、QUIC新功能

QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流"
是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：

- **实现了类似TCP的流量控制、传输可靠性的功能**

  虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。

- **实现了快速握手功能**

  由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。**0RTT 建连可以说是 QUIC 相比
  HTTP2 最大的性能优势**。

- **集成了TLS加密功能**

- **多路复用，彻底解决TCP中队头阻塞的问题**

  和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。

- **连接迁移**

  TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID
  不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。

### XSS、CSRF、DDoS攻击原理以及避免方式

* `XSS`(`Cross-Site Scripting`，**跨站脚本攻击**)：一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 `cookie，session tokens`
  ，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。

* `CSRF`（`Cross-site request forgery`，**跨站请求伪造**）：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

* `DDoS` （`Distributed Denial of Service`，**分布式拒绝服务**）：其原理就是利用大量的请求造成资源过载，导致服务不可用。

### `XSS` 避免方式

1. `url`参数使用`encodeURIComponent`方法转义
2. 尽量不是有`InnerHtml`插入`HTML`内容
3. 使用特殊符号、标签转义符。

### `CSRF` 避免方式

1. 添加验证码
2. 使用token

- 服务端给用户生成一个token，加密后传递给用户
- 用户在提交请求时，需要携带这个token
- 服务端验证token是否正确

### `DDos` 避免方式

1. 限制单IP请求频率。
2. 防火墙等防护设置禁止`ICMP`包等
3. 检查特权端口的开放





