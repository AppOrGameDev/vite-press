# 计算机网络

## HTTP

`HTTP` 是一种用于传输超文本的协议，是互联网上应用最为广泛的协议之一。

1. **基本概念**

- `HTTP` 是一个无状态协议：即每个请求之间是没有关联的，每个请求都是独立的。
- `HTTP` 是基于请求和响应的：客户端发送请求给服务器，服务器返回响应给客户端。
- `HTTP` 是文本协议：`HTTP` 使用文本格式进行通信，请求和响应都是由头部和主体两部分组成的文本格式。

2. **工作原理**

- 客户端发起请求：客户端使用 `HTTP` 协议向服务器发送请求，请求包含请求方法、请求URL、请求头和请求主体等信息。
- 服务器响应请求：服务器接收到客户端的请求后，进行处理并返回响应，响应包含状态码、响应头和响应主体等信息。
- 连接关闭：完成请求和响应之后，客户端和服务器之间的连接会被关闭。

HTTP的常见请求方法：

| 方法      | 作用              |
|---------|-----------------|
| GET     | 获取资源            |
| POST    | 提交数据            |
| PUT     | 更新资源            |
| DELETE  | 删除资源            |
| HEAD    | 获取响应头信息         |
| OPTIONS | 获取服务器支持的请求方法等信息 |

总的来说，`HTTP` 是一种简单、可靠、可扩展的协议，它在互联网中扮演着重要的角色，被广泛应用于Web开发、移动应用、API接口等领域。


### GET与POST的区别

`GET` 和P `OST` 是 `HTTP` 协议中常用的两种请求方法，它们之间的主要区别如下：

1. 参数传递方式不同

- `GET` 请求：参数是通过 `URL` 传递的，即将参数拼接在URL后面。
- `POST` 请求：参数是通过请求体传递的，即将参数放在请求体中，请求头中会包含 `Content-Type` 字段来说明请求体中的数据格式。

2. 参数传递大小限制不同

- `GET` 请求：由于参数是通过 `URL` 传递的，因此传递的参数大小有限制，通常不超过 `2KB`。
- `POST` 请求：由于参数是通过请求体传递的，因此传递的参数大小没有限制。

3. 安全性不同

- `GET` 请求：参数是暴露在 `URL` 中的，因此在请求过程中容易被拦截、篡改或缓存，不适合传递敏感信息。
- `POST` 请求：参数是放在请求体中的，相对于 `GET` 请求更安全，适合传递敏感信息。

4. 缓存机制不同

- `GET` 请求：浏览器会缓存 `GET` 请求的结果，下次请求相同的 `URL` 时，直接从缓存中获取，不会重新请求服务器。
- `POST` 请求：浏览器**不**会缓存 `POST` 请求的结果，每次请求都会向服务器发送请求。

5. 应用场景不同

- `GET` 请求：通常用于获取数据，如搜索、分页等。
- `POST` 请求：通常用于提交数据，如登录、注册等。

总之，`GET` 和 `POST` 请求各有优缺点，需要根据实际业务需求选择合适的请求方法。

### HTTP报文组成

`HTTP` 报文是 `HTTP` 协议中的核心概念之一，包括两部分：请求报文和响应报文。

> HTTP报文是一个文本格式的信息，它包含了请求或响应所需要的全部信息，使得客户端和服务器端能够有效地进行通信和数据传输。

#### 请求报文

请求报文包括请求行、请求头、请求体三部分，格式如下：

```
<method> <request-URL> <version>
<headers>
<body>
```

其中：

- 请求行：包括请求方法、请求 `URL` 和协议版本，用空格分隔；
- 请求头：包括多个键值对，每个键值对用冒号分隔，多个键值对之间用回车符和换行符分隔；
- 请求体：用于携带请求参数和数据，请求体可以为空。

#### 响应报文

响应报文也包括三部分：状态行、响应头和响应体，格式如下：

```
<version> <status> <reason-phrase>
<headers>
<body>
```

其中：

- 状态行：包括协议版本、状态码和状态消息，用空格分隔；
- 响应头：包括多个键值对，每个键值对用冒号分隔，多个键值对之间用回车符和换行符分隔；
- 响应体：用于携带响应结果和数据，响应体可以为空。

#### Request Header

`Request Header`（请求头）是 `HTTP` 请求报文中的一部分，包含了客户端（浏览器或应用程序）向服务器发送请求时的附加信息，以键值对的形式组织。常见的请求头有：

- User-Agent：客户端的类型及版本号
- Referer：请求来源的URL
- Accept：客户端支持的MIME类型
- Accept-Language：客户端支持的语言类型
- Accept-Encoding：客户端支持的压缩类型
- Host：请求的服务器域名
- Connection：客户端与服务器之间连接的类型
- Cookie：客户端存储的Cookie信息
- Cache-Control：请求缓存的控制参数

请求头的作用是提供给服务器更多的信息，以便服务器更好地处理请求。

#### Response Header

`Response Header`（响应头）是 `HTTP` 响应报文中的一部分，包含了服务器对客户端请求的响应信息，以键值对的形式组织。常见的响应头有：

- Content-Type：响应内容的MIME类型
- Content-Length：响应内容的长度
- Cache-Control：响应缓存的控制参数
- Set-Cookie：服务器要求客户端存储的Cookie信息
- Location：重定向的URL地址
- ETag：资源的标识符，用于缓存控制
- Last-Modified：资源的最后修改时间，用于缓存控制
- Expires：资源的过期时间，用于缓存控制

响应头的作用是告知客户端服务器对请求的响应情况，以便客户端进行下一步处理。

### HTTPS

1. **基本概念**

`HTTPS` 是 `HTTP` 协议的一种安全版本，通常使用 `SSL/TLS` 协议进行加密。它在数据传输的过程中使用了公钥加密和私钥解密的方式来保护数据的机密性和完整性。`HTTPS`
协议在数据传输过程中，采用了多种加密技术，包括对称密钥加密、非对称密钥加密和消息摘要算法等。这些技术保证了数据在传输过程中不会被黑客窃取或篡改。

2. **作用**

使用 `HTTPS` 协议可以防止中间人攻击、身份伪装、数据篡改、数据窃听等问题。通过数字证书，可以验证网站的真实性，确保通信双方的身份，保障用户的隐私和安全。

#### HTTP 和 HTTPS 的区别

`HTTP` 和 `HTTPS` 都是应用层协议，但 `HTTPS` 在 `HTTP` 的基础上增加了安全层，使得数据在传输过程中更加安全可靠。下面是 `HTTP` 和 `HTTPS` 的区别：

1. `HTTP` 使用明文传输数据，而 `HTTPS` 通过 `SSL/TLS` 加密数据传输；

2. `HTTP` 的默认端口是 `80`，`HTTPS` 的默认端口是 `443`；

3. `HTTP` 在通信过程中没有身份验证，而 `HTTPS` 通过 `SSL/TLS` 建立身份验证机制，可以防止身份被冒充；

4. `HTTP` 数据传输速度更快，因为 `HTTPS` 增加了加密、解密和身份验证等额外的步骤，需要消耗更多的计算资源和时间；

5. `HTTP` 使用的证书是申请成本较低的 `DV`（Domain Validation）证书，而 `HTTPS` 使用的证书是成本较高的 `EV`（Extended Validation）证书，可以提供更高的安全性和可信度。

总之，HTTPS比HTTP更加安全可靠，但在性能方面会有一定的损失。因此，在对安全性要求较高的场合，应该使用HTTPS。

#### HTTPS 协议的优缺点

`HTTPS` 协议相比 `HTTP` 协议，具有以下优点和缺点：

**优点：**

1. 安全性高：`HTTPS` 协议利用 `SSL/TLS` 加密传输数据，能够有效地保障数据的安全性，可以防止数据被窃取、篡改、劫持等攻击。

2. 防止中间人攻击：`HTTPS` 采用了证书机制，能够有效地防止中间人攻击。

3. 提高网站的信誉度：`HTTPS` 协议能够保证网站的真实性和完整性，让用户更加信任网站，从而提高了网站的信誉度。

4. 支持更多的浏览器和搜索引擎：现在的浏览器和搜索引擎都支持 `HTTPS` 协议，使用https协议能够让网站更好的展示在搜索结果中，提高曝光率。

**缺点：**

1. 加密、解密过程会消耗更多的计算资源和时间，会降低服务器的性能，增加服务器的负担。

2. 证书需要向 `CA` 机构购买，成本较高，不是所有的网站都能够承受。

3. `HTTPS` 协议对缓存的支持不够好，会导致网站的访问速度较慢，需要额外的服务器资源来支持 `HTTPS` 的加密和解密过程。

4. `HTTPS` 协议无法缓存静态文件，对于一些大文件的下载，`HTTPS` 的效率并不是很高。

综上所述，`HTTPS` 协议虽然有一些缺点，但是其安全性和信誉度优势明显，对于一些需要保障数据安全的网站和交易场景，采用 `HTTPS` 协议是必要的。

### 状态码

`HTTP` 的状态码用于表示服务器处理请求的结果:

- 1xx：信息提示，表示请求已被接受，需要继续处理。
- 2xx：成功，表示请求已被成功处理和接受。
- 3xx：重定向，表示需要进行进一步操作才能完成请求。
- 4xx：客户端错误，表示请求包含错误或无法被处理。
- 5xx：服务器错误，表示服务器在尝试处理请求时发生了错误。

#### 常见状态码

- 200 OK：客户端请求成功
- 301 Moved Permanently：所请求的页面已经永久重定向至新的URL
- 302 Found：所请求的页面已经临时重定向至新的URL
- 304 Not Modified：未修改。
- 403 Forbidden：对请求页面的访问被禁止
- 404 Not Found：请求资源不存在
- 500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用
- 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常

#### 更多状态码

- 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码
  - 100：继续，服务器已经接收到请求头，并且客户端应该继续发送请求体（通常用于POST请求）。
  - 101：切换协议，请求者已要求服务器切换协议，服务器已确认并准备切换

- 2xx（成功）表示成功处理了请求的状态码
  - `200`：成功，服务器已经成功处理了请求
  - 201：已创建，请求成功并且服务器创建了新的资源
  - 202：已接受，服务器已接受请求，但尚未处理
  - 203：非授权信息，服务器已经成功处理了请求，但返回的信息可能来自另一来源
  - 204：无内容，服务器成功处理了请求，但没有返回任何内容
  - 205：重置内容，服务器成功处理了请求，但没有返回任何内容

- 3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向
  - 300：多种选择，针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择
  - `301`：永久移动，请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置
  - `302`：临时移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
  - 303：查看其它位置，请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码
  - `304`：未修改，自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容
  - 305：使用代理，请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
  - `307`：临时性重定向，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求

- 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理
  - `400`：错误请求 服务器不理解请求的语法
  - `401`：未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
  - `403`：禁止 服务器拒绝请求
  - `404`：未找到 服务器找不到请求的网页
  - 405：方法禁用 禁用请求中指定的方法
  - 406：不接受 无法使用请求的内容特性响应请求的网页
  - `407`：需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理
  - `408`：请求超时 服务器等候请求时发生超时
  - 410：已删除 如果请求的资源已永久删除，服务器就会返回此响应
  - `413`：请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力
  - `414`：请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理

- 5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错
  - `500`：服务器内部错误 服务器遇到错误，无法完成请求
  - 501：尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
  - `502`：错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应
  - `503`：服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
  - `504`：网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求
  - 505：HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本

#### 304状态码过程

1. 浏览器请求资源时，先检查资源的 `Expires` 和 `Cache-Control` 值，如果缓存仍然有效，则直接使用缓存，返回状态码200，并在响应头中添加 `from cache` 字样，不会请求数据。

2. 如果缓存失效，浏览器发送带有 `If-None-Match` 和 `If-Modified-Since` 头的条件请求到服务器，请求头中的 `If-None-Match` 值是上一次请求返回的 `ETag` 值，`If-Modified-Since`
   是上一次请求返回的 `Last-Modified` 值。

3. 服务器收到条件请求后，检查资源的 `ETag` 和 `Last-Modified` 值是否匹配，如果匹配，则表示资源没有更新，返回状态码304，告诉浏览器可以直接使用缓存。

4. 如果资源已更新，则服务器返回新的资源，状态码为200，并在响应头中添加新的 `ETag` 和 `Last-Modified` 值，浏览器会更新缓存，并在下一次请求中使用新的缓存。

总之，HTTP 304状态码的过程是一种优化缓存机制的方式，减少网络带宽和服务器负载。通过比较资源的 `ETag` 和 `Last-Modified` 值，避免了不必要的数据传输，提高了资源请求的效率。

### 请求跨域问题

跨域问题指的是：浏览器限制了当前网页从不同的域名、端口、协议访问另一个网站的资源的限制。浏览器是基于同源策略来限制跨域访问的。

同源策略指的是：**协议**、**域名**、**端口号**必须完全相同

解决跨域指的是：通过各种方式，避开浏览器的安全限制

常见的跨域解决方案有以下几种：

1. `JSONP`：通过动态创建 `<script>` 标签，通过 `src` 属性加载一个 `API`，并在 `url` 参数中携带回调函数名，服务端返回一个执行该回调函数的 `JavaScript` 脚本。`JSONP` 仅支持 `GET`
   请求，且只能用于跨域获取数据，无法实现向服务器提交数据。

2. `CORS`：服务器设置响应头中的 `Access-Control-Allow-Origin` 字段，允许指定的域名跨域访问该资源。使用 `CORS` 需要服务器端支持，且需要前端进行额外的配置，可以支持 `GET/POST` 等请求类型。

3. `代理服务器`：前端请求自己的服务器，自己的服务器再去请求目标服务器，最后将目标服务器的响应返回给前端。由于是同源请求，不存在跨域问题，但需要在自己的服务器上进行配置。

4. `WebSocket`：`WebSocket` 协议是一种在单个 `TCP` 连接上进行全双工通信的协议，它不受同源策略的限制。通过在客户端和服务器之间建立 `WebSocket` 连接，可以在跨域情况下进行实时通信。

5. `postMessage`：可以在跨域的窗口之间发送消息，通过对消息的监听来实现跨域通信。

## TCP

**TCP/IP网络模型**是互联网最基本的通信模型，它是由两个协议簇（Protocol Suite）组成：`TCP`（传输控制协议）和 `IP`（网际协议）。

TCP/IP网络模型共分为四层，分别为：

1. 应用层（Application Layer）：处理特定应用程序的协议，例如 `HTTP`、`FTP`、`SMTP` 等。

2. 传输层（Transport Layer）：提供端到端的接口，负责向两台主机中的应用程序提供通信服务，常用协议有 `TCP`、`UDP` 等。

3. 网络层（Internet Layer）：处理网络上的流量路由和寻址，主要包括 `IP` 协议。

4. 数据链路层（Link Layer）：负责处理网络物理设备和网络之间的数据传输，常用协议有 `Ethernet`、`PPP` 等。

`TCP/IP` 网络模型与 `OSI` 网络模型相似，但是它们之间存在一些差异。`TCP/IP` 网络模型是一个更加实用的模型，主要应用于互联网和局域网等通信网络。

### TCP 三次握手

1. 第一次握手：客户端向服务器发送 `SYN` 包（`SYN=j`）并进入 `SYN_SENT` 状态，等待服务器确认。

2. 第二次握手：服务器收到客户端的 `SYN` 包后，确认客户端的 `SYN`（`ACK=j+1`），并向客户端发送一个自己的 `SYN` 包（`SYN=k`），即SYN+ACK包，此时服务器进入 `SYN_RECV` 状态。

3. 第三次握手：客户端收到服务器的 `SYN+ACK` 包后，向服务器发送确认包 `ACK`（`ACK=k+1`），此包发送完毕，客户端和服务器进入 `ESTABLISHED` 状态，`TCP` 连接建立成功。

:::warning
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
:::


### TCP 四次挥手

1. 客户端发送连接释放报文段（`FIN=1，seq=x`），并进入 `FIN_WAIT_1` 状态，等待服务端确认。

2. 服务端收到连接释放报文段后，发送确认报文段（`ACK=1，ack=x+1`），进入 `CLOSE_WAIT` 状态，等待客户端发送连接释放报文段。

3. 如果服务端有要发送的数据，会先将数据发送完毕，然后发送连接释放报文段（`FIN=1，seq=y`），进入 `LAST_ACK` 状态，等待客户端确认。

4. 客户端收到连接释放报文段后，发送确认报文段（`ACK=1，ack=y+1`），进入 `TIME_WAIT` 状态，等待 `2MSL` 后进入 `CLOSED` 状态。`2MSL` 是为了确保服务端收到了确认报文段，如果没有收到则会重传连接释放报文段。

5. 服务端收到客户端发送的确认报文段后，进入 `CLOSED` 状态，释放连接。

6. 客户端等待 `2MSL` 后，确认服务端已经收到了确认报文段，进入 `CLOSED` 状态，释放连接。

:::tip
总结来说，`TCP` 四次挥手过程的目的是为了确保客户端和服务端都知道连接已经关闭，并且在关闭连接之前，双方都有机会传递完所有的数据。在这个过程中，双方都会进入一些状态来等待对方的确认和数据传输。
:::

### TCP 和 UDP 的区别

`TCP` 和 `UDP` 是传输层协议，用于在网络上传输数据，但它们之间有几个重要的区别。

1. 可靠性：`TCP` 是可靠的，它确保数据包的正确性和完整性。它使用三次握手建立连接，确认数据包的接收，并保证数据包的顺序。而 `UDP` 则是不可靠的，因为它不保证数据包的正确性、完整性和顺序。

2. 连接：`TCP` 是面向连接的协议，建立连接、数据传输和释放连接都需要经过一定的过程。`UDP` 则是无连接的，发送端只是直接把数据包发送给接收端，不需要连接的建立和释放过程。

3. 效率：`UDP` 比 `TCP` 快，因为它不需要建立连接和保证数据包的可靠传输。但是，由于 `UDP` 不保证数据包的可靠性和完整性，所以需要应用程序来负责处理这些问题。

4. 应用场景：`TCP` 适用于需要可靠数据传输的应用程序，如文件传输、电子邮件、Web应用程序等。`UDP` 适用于需要快速数据传输的应用程序，如视频、音频、游戏等。

总之，`TCP` 提供了可靠性和顺序控制，而 `UDP` 提供了快速传输和更少的开销。选择哪种协议取决于应用程序的需求和特点。

### TCP 粘包

`TCP` 粘包是指：发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

粘包问题是指：在网络通信过程中，由于数据包较小或传输速度过快，多个数据包被缓存在发送方，最终一次性发送到接收方，导致接收方无法正确区分各个数据包之间的边界，从而导致数据包的内容出现混乱或解析错误的问题。

**出现原因：**

1. 发送方缓存数据包过多或传输速度过快，导致多个数据包一次性发送。

2. 接收方读取数据包的方式不当，比如采用固定长度的方式读取数据，而不考虑数据包之间的边界问题。

**解决对策：**

1. 消息定长：发送方发送的消息长度固定，接收方按照固定长度读取数据包。

2. 在数据包中增加特殊字符分隔符：发送方在数据包尾部添加特定分隔符，接收方根据分隔符切分数据包。

3. 将消息分为消息头和消息体：消息头中包含数据包长度等信息，接收方先读取消息头中的信息，再按照消息头中的长度读取消息体。

4. 使用更高级别的协议：比如 `TCP` 协议提供了流控制、拥塞控制等机制，可以保证传输的可靠性，同时也能够避免粘包问题的产生。

## 浏览器的缓存机制

浏览器缓存机制可以分为强制缓存和协商缓存两种方式。

- 强制缓存：

当浏览器第一次请求资源时，服务器返回的响应头中会包含 `Cache-Control` 和 `Expires` 字段，用于控制资源的缓存。浏览器在接收到资源后，会将其保存到本地，并在下一次请求该资源时，先判断本地缓存是否过期，如果未过期，则直接从本地缓存读取资源，不再向服务器发起请求。

- 协商缓存：

当浏览器判断本地缓存已经过期时，会向服务器发起请求，服务器返回的响应头中会包含 `Last-Modified` 和 `ETag`
字段，用于标识资源的最后修改时间和唯一标识。浏览器在接收到资源后，会将其保存到本地，并在下一次请求该资源时，先向服务器发起请求，请求头中包含上一次响应头中返回的 `Last-Modified` 和 `ETag`
值，服务器会根据这些值判断该资源是否有更新，如果没有更新，则返回 `304` 状态码，并告诉浏览器可以从本地缓存中获取该资源；如果有更新，则返回新的资源内容和响应头，并将其保存到本地缓存。

## 客户端与服务端长连接

下面是一些客户端与服务端长连接的方式以及它们的优缺点：

1. HTTP 长连接

优点：

- 可以重用一个 `TCP` 连接，减少了每次请求时建立 `TCP` 连接的开销。
- 适用于轻量级的数据交换，比如 `Web` 资源的传输。
- 由于使用 `HTTP` 协议，因此兼容性较好，可用于浏览器和服务器之间的通信。

缺点：

- 无法实现服务器端主动推送数据，需要客户端轮询或者使用 `Comet` 等技术来模拟长连接。
- 长时间保持连接会占用服务器的资源，如果同时有大量客户端连接，则会造成服务器压力过大。
- `HTTP` 协议的头部信息比较冗余，增加了数据传输的开销。

2. WebSocket 长连接

优点：

- 建立在 `HTTP` 协议之上，与 `HTTP` 协议兼容，因此能够穿透大多数防火墙和代理服务器。
- 可以实现服务器端主动推送数据，可以用于实时通信、在线游戏等场景。
- 采用二进制传输，传输效率高。
- WebSocket 协议采用了基于帧的传输方式，消息的边界明确，便于解析。

缺点：

- 对服务器端的性能要求较高，需要保持大量的连接和维护状态，服务器压力较大。
- 长时间保持连接会占用服务器的资源，如果同时有大量客户端连接，则会造成服务器压力过大。
- 需要客户端和服务器端都支持 `WebSocket` 协议。

3. TCP 长连接

优点：

- 直接建立在 `TCP` 层，没有 `HTTP` 协议头的开销，传输效率高。
- 可以实现服务器端主动推送数据。
- 对于较大量级的数据交换，`TCP` 长连接的效率比 `HTTP` 长连接要高。

缺点：

- 需要客户端和服务器端都支持 `TCP` 协议。
- `TCP` 长连接需要维护连接状态，因此对服务器的性能要求较高。
- 如果同时有大量客户端连接，则会造成服务器压力过大。

:::tip
- 对于简单的 `Web` 应用，使用 `HTTP` 长连接即可满足需求；
- 对于实时通信或在线游戏等场景，可以选择 `WebSocket` 长连接；
- 而对于大量数据交换的场景，`TCP` 长连接可能更为适合。
:::

## Socket 建立网络连接

使用 Socket 建立网络连接的步骤如下：

1. 创建 `Socket` 对象：客户端和服务端都需要创建 `Socket` 对象。客户端创建 `Socket` 对象时，需要指定服务端的 `IP` 地址和端口号；服务端创建 `Socket` 对象时，只需要指定端口号。

2. 连接服务端：客户端需要调用 `Socket` 对象的 `connect()` 方法连接服务端。服务端不需要调用该方法，因为服务端是被动的，等待客户端连接即可。

3. 获取输入输出流：连接成功后，客户端和服务端都需要获取对应的输入输出流，用于数据的读写。

4. 进行数据的读写：通过输入输出流进行数据的读写，客户端和服务端都可以发送和接收数据。

5. 关闭连接：使用完毕后，需要关闭 `Socket` 连接，释放资源。

:::warning
在使用 `Socket` 进行网络编程时，可能会抛出各种异常，如 `SocketException`、`IOException` 等，需要进行异常处理。
:::

## 对称加密和非对称加密

非对称加密和对称加密是两种常用的加密方式。

- 对称加密是指发送方和接收方使用同一把密钥进行加密和解密。这种加密方式速度较快，但是密钥必须安全地传输，如果密钥泄露了，那么加密就失去了意义。

- 非对称加密是指使用一对公开密钥和私有密钥进行加密和解密。公开密钥是公开的，任何人都可以获得，用于加密数据；私有密钥只有私有密钥的拥有者可以使用，用于解密数据。非对称加密方式相对对称加密更加安全，因为即使攻击者获得了公开密钥，也无法解密数据，必须拥有私有密钥才能进行解密。

:::tip
通常，在实际应用中，对称加密和非对称加密会结合使用。例如，使用对称加密算法加密数据，然后使用非对称加密算法加密对称密钥，这样可以保证数据的安全性，并且在保证安全性的前提下提高效率。
:::

**对称加密的特点：**

- 对称加密使用相同的密钥进行加密和解密。

- 加密和解密的速度非常快。

- 密钥必须安全地传输给接收方，否则容易被拦截。

- 密钥管理非常困难，特别是在多个用户之间共享密钥时。

**非对称加密的特点：**

- 非对称加密使用两个密钥进行加密和解密，分别为公钥和私钥。

- 加密和解密的速度较慢。

- 公钥可以公开发布，私钥必须严格保密。

- 密钥管理相对容易，因为每个用户都有自己的密钥对。

**它们之间的区别：**

- 对称加密和非对称加密的密钥数量不同，对称加密使用相同的密钥进行加密和解密，而非对称加密使用两个密钥，分别为公钥和私钥。

- 加密和解密速度不同，对称加密速度非常快，而非对称加密速度相对较慢。

- 密钥的管理方式不同，对称加密的密钥管理非常困难，而非对称加密的密钥管理相对容易。

- 对称加密相对来说不太安全，因为密钥需要安全地传输给接收方，否则可能被拦截，而非对称加密相对较安全，因为公钥可以公开发布。

## HTTP1、HTTP2、HTTP3

`HTTP` (Hypertext Transfer Protocol) 是一种用于客户端和服务器之间进行通信的协议。在过去几十年中，`HTTP` 已经经历了多次重大更新，其中最重要的三个版本是 `HTTP1`、`HTTP2` 和 `HTTP3`
。它们之间的区别如下：

1. `HTTP1`：`HTTP1.0` 最初发布于 `1996` 年，然后在 `1999` 年被 `HTTP1.1` 取代。`HTTP1.x `
   是一种基于文本的协议，使用明文传输数据，不支持请求和响应的多路复用，每个请求都需要建立一个新的 `TCP`
   连接。这导致了一些性能瓶颈，例如延迟和带宽限制。

2. `HTTP2`：`HTTP2` 在 `2015` 年发布，是 `HTTP1.x` 的升级版。它引入了二进制协议，支持请求和响应的多路复用，可以在一个 `TCP`
   连接上同时发送多个请求，降低了延迟和提高了带宽利用率。此外，`HTTP2`
   还支持服务器推送，可以在客户端请求之前将资源推送到客户端缓存，从而提高性能。

3. `HTTP3`：`HTTP3` 是最新的 `HTTP` 协议，于 `2020` 年发布。它基于 `QUIC`（Quick UDP Internet Connections）协议，使用 `UDP` 而不是 `TCP` 来传输数据。由于 `UDP`
   支持更高的并发连接和更低的延迟，`HTTP3`
   可以更快地传输数据，并支持请求和响应的多路复用。此外，`HTTP3` 还支持 `0-RTT`（Zero Round Trip Time）握手，可以减少建立连接所需的时间。

`HTTP1.1` 的优点：

- 兼容性好：`HTTP1.1` 被广泛支持和采用。
- 可缓存性：`HTTP1.1` 支持多种缓存技术，可以缓存网页，提高网页加载速度。
- 资源异步加载：使用 `HTTP1.1` 可以通过在页面中嵌入多个资源链接的方式异步加载资源，提高了页面的并发度和渲染速度。

`HTTP1.1` 的缺点：

- 队头阻塞：`HTTP1.1` 使用的是串行的请求和响应方式，如果某个请求响应慢，后续的请求需要等待，会出现队头阻塞的问题。
- 无状态：`HTTP1.1` 协议本身无状态，需要使用 `Cookie` 等技术来实现状态管理。
- 头部冗余：`HTTP1.1` 的头部信息没有压缩，每次请求和响应都需要重复传输相同的头部信息，导致传输数据量增大。

`HTTP2` 的优点：

- 多路复用：`HTTP2` 使用二进制协议，支持多路复用，可以在一个连接上同时处理多个请求和响应。
- 首部压缩：`HTTP2` 使用首部压缩技术，可以减少请求和响应的头部信息传输量，提高了传输效率。
- 服务器推送：`HTTP2` 支持服务器推送技术，可以在客户端请求前主动向客户端推送相应资源，提高了响应速度和性能。

`HTTP2` 的缺点：

- 依赖 `HTTPS`：`HTTP2` 协议必须依赖 `TLS` 协议，需要使用 `HTTPS` 传输数据。
- 突发流量：多路复用可以并发处理多个请求和响应，但也会导致某个请求耗费过多的时间，影响其他请求的响应速度。
- 资源消耗：`HTTP2` 对于每个连接都需要维护状态，资源消耗较大。

`HTTP3` 的优点：

- 基于 `QUIC` 协议：`HTTP3` 基于 `QUIC` 协议，具有更好的安全性和传输效率。
- 集成了 `TLS`：`HTTP3` 集成了 `TLS`，保证了数据的安全性。
- 抗干扰：`HTTP3` 通过使用 `UDP` 协议，支持快速重传和自适应拥塞控制，抵抗网络干扰。

`HTTP3` 的缺点：

- 兼容性：`HTTP3` 的兼容性较差，需要客户端和服务器端都支持 `HTTP3` 协议。
- 连接建立：`HTTP3` 协议需要建立多个连接来提高传输效率，增加了连接建立的复杂度。
- 难以调试：`HTTP3` 的调试工具还不够成熟，调试过程比较困难。

:::warning

- `HTTP/2` 和 `HTTP/3` 是对 `HTTP/1.1` 的升级和改进，不是对 `HTTP/1.0` 的重写。
- 虽然 `HTTP/1.1` 是 `HTTP/1.0` 的改进版本，但 `HTTP/2` 和 `HTTP/3` 是对 `HTTP/1.1` 的更进一步的改进和升级。
- `HTTP/1.1` 相对于 `HTTP/1.0` 的改进主要是在持久连接、管线化、缓存等方面，而 `HTTP/2` 和 `HTTP/3` 则在多路复用、头部压缩、流量控制等方面有了很大的改进。
  :::

## 网络安全攻击类型

`XSS`、`CSRF` 和 `DDoS` 攻击都是常见的网络安全攻击类型，以下是它们的原理和避免方式：

1. XSS（跨站脚本攻击）：

`XSS` 攻击是指攻击者利用网站漏洞，在页面中注入恶意脚本，当用户访问包含这些恶意脚本的页面时，脚本会在用户浏览器中执行，进而盗取用户的敏感信息。`XSS` 攻击主要有两种类型：存储型和反射型。

避免方式：

- 输入验证：对用户输入的数据进行校验和过滤。
- 输出编码：对输出到页面的数据进行编码，避免恶意脚本被执行。
- `Cookie` 安全：将 `cookie` 标记为 `HttpOnly`，使得只有在服务端可以访问，而客户端的 `JavaScript` 无法访问。

2. CSRF（跨站请求伪造）：

`CSRF` 攻击是指攻击者通过各种方式欺骗用户在另一个网站上执行恶意操作，进而完成攻击。攻击者通过伪造用户的身份，向目标网站发起请求，实现攻击目的。

避免方式：

- 验证码：在敏感操作上添加验证码，防止攻击者利用脚本发起攻击。
- 随机令牌：在敏感操作中添加随机的令牌，防止攻击者伪造用户身份。
- `Referer` 检查：检查请求来源，防止攻击者通过直接构造请求来攻击。

3. DDoS（分布式拒绝服务攻击）：

`DDoS` 攻击是指攻击者利用大量的计算机或设备向目标服务器发起大量请求，占用服务器的带宽和资源，导致服务不可用。`DDoS` 攻击可以分为几种类型，如 `SYN Flood` 攻击、`UDP Flood`
攻击和 `HTTP Flood` 攻击等。

避免方式：

- 流量清洗：使用专业的 `DDoS` 清洗设备，可以对流量进行过滤和清洗，防止攻击流量影响正常流量。
- 网络拓扑优化：合理优化网络拓扑，可以减轻 `DDoS` 攻击对网络的影响。
- 服务器防护：可以通过限制单个 `IP` 地址的最大连接数、使用防火墙、开启 `DDoS` 防护等方式，提高服务器的防护能力。




